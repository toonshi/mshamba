import Nat        "mo:base/Nat";
import Nat64      "mo:base/Nat64";
import Int        "mo:base/Int";
import Principal  "mo:base/Principal";
import Debug      "mo:base/Debug";
import Array      "mo:base/Array";
import Blob       "mo:base/Blob";
import Nat8       "mo:base/Nat8";
import Buffer     "mo:base/Buffer";
import Iter "mo:base/Iter";
// Import generated bytes module
import wasmICRC1 "wasm_bytes_icrc1/lib";

persistent actor TokenFactory {

  // Minimal management canister interface
  type ICManagement = actor {
    create_canister : ({ settings : ?{ controllers : ?[Principal] }}) -> async { canister_id : Principal };
    install_code : ({ mode : { #install; #reinstall; #upgrade }; canister_id : Principal; wasm_module : Blob; arg : Blob }) -> async ();
  };

  // Types
  type Account = { owner : Principal; subaccount : ?Blob };
  type Value =  { #Nat :Nat; #Int :Int; #Text :Text; #Blob :Blob };
  type ArchiveOptions = {
    trigger_threshold : Nat64;
    num_blocks_to_archive : Nat64;
    node_max_memory_size_bytes : ?Nat64;
    max_message_size_bytes : ?Nat64;
    controller_id : Principal;
  };
  type InitialBalance = { account : Account; amount : Nat };
  type LedgerInit = {
    token_symbol : Text;
    token_name : Text;
    minting_account : Account;
    transfer_fee : Nat;
    metadata : ?[(Text, Value)];
    initial_balances : [InitialBalance];
    archive_options : ArchiveOptions;
    feature_flags : ?{ icrc2 : Bool };
    maximum_number_of_accounts : ?Nat64;
    accounts_overflow_trim_quantity : ?Nat64;
  };
  type Allocation = { owner : Principal; allocation : Nat };

  // Helpers
  func percent(n : Nat, p : Nat) : Nat { (n * p) / 100 };
  func sumAll(xs : [Allocation]) : Nat {
    var s : Nat = 0;
    for (a in xs.vals()) { s += a.allocation };
    s
  };

  
 


  public shared ({ caller }) func createFarmLedger(
    tokenName        : Text,
    tokenSymbol      : Text,
    farmerId         : Principal,
    initialSupply    : Nat,
    investorAllocs   : [Allocation],
    governance       : ?Principal,
    vestingDays      : Nat,
    transferFee      : Nat,
    extraControllers : [Principal],
    cyclesToSpend    : ?Nat
  ) : async Principal {

    let chunks = wasmICRC1.chunks;

     func getChunk(i : Nat) : [Nat8] {
    if (i < chunks.size()) {
      chunks[i]
    } else {
      []
    }
    };
    let ic : ICManagement = actor ("aaaaa-aa");

    assert initialSupply > 0;

    // Tokenomics
    let reserveAmt : Nat = percent(initialSupply, 10);
    let maxInvest  : Nat = percent(initialSupply, 39);
    let investSum  : Nat = sumAll(investorAllocs);
    if (investSum > maxInvest) Debug.trap("Investor allocations exceed 39% cap");

    let farmerAllocation : Nat = initialSupply - reserveAmt - investSum;
    let minFarmer        : Nat = percent(initialSupply, 51);
    if (farmerAllocation < minFarmer) Debug.trap("Farmer allocation would fall below required 51%");

    // Build initial balances
    let farmerAccount : Account = { owner = farmerId; subaccount = null };
    let investorEntries : [InitialBalance] =
      Array.map<Allocation, InitialBalance>(investorAllocs, func (a) : InitialBalance {
        { account = { owner = a.owner; subaccount = null }; amount = a.allocation }
      });
    let reserveAccount : Account = { owner = caller; subaccount = null };
    let initialBalances : [InitialBalance] =
      Array.append<InitialBalance>(
        [{ account = farmerAccount; amount = farmerAllocation }],
        Array.append<InitialBalance>(
          investorEntries,
          [{ account = reserveAccount; amount = reserveAmt }]
        )
      );

    // Mint authority
    let mintAuthority : Account = switch (governance) {
      case (?g) { { owner = g; subaccount = null } };
      case null  { { owner = farmerId; subaccount = null } };
    };

    // Archive options
    let archive : ArchiveOptions = {
      trigger_threshold = Nat64.fromNat(2000);
      num_blocks_to_archive = Nat64.fromNat(1000);
      node_max_memory_size_bytes = null;
      max_message_size_bytes = null;
      controller_id = caller;
    };

    let init : LedgerInit = {
      token_symbol = tokenSymbol;
      token_name = tokenName;
      minting_account = mintAuthority;
      transfer_fee = transferFee;
      metadata = null;
      initial_balances = initialBalances;
      archive_options = archive;
      feature_flags = ?{ icrc2 = true };
      maximum_number_of_accounts = null;
      accounts_overflow_trim_quantity = null;
    };

    let defaultCycles : Nat = 1_000_000_000;
    let spend : Nat = switch (cyclesToSpend) { case (?n) n; case null defaultCycles };

    let baseControllers : [Principal] = [caller, farmerId];
    let controllers : [Principal] = Array.append<Principal>(baseControllers, extraControllers);

    // Create canister
    let { canister_id } = await (with cycles = spend) ic.create_canister({
      settings = ?{ controllers = ?controllers }
    });

    // Build wasm Blob dynamically from all chunks using Buffer
    let buf = Buffer.Buffer<Nat8>(1024);


for (i in Iter.range(0, wasmICRC1.__num_chunks - 1)) {
    let chunk : [Nat8] = getChunk(i);
    for (n in chunk.vals()) {
        buf.add(n);
    }
};
    let wasm : Blob = Blob.fromArray(Buffer.toArray(buf));

    // Convert init to candid
    let arg : Blob = to_candid(init);

    // Install code
    await ic.install_code({
      mode = #install;
      canister_id = canister_id;
      wasm_module = wasm;
      arg = arg;
    });

    canister_id
  };
};
